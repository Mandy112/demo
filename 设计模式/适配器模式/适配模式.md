##适配器模式与门面模式的异同
适配模式与门面模式很像，都要对别的对象进行包装并改变其呈现的接口，差别在于如何改变接口。
门面模式并不提供额外的选择，有时为了方便完成常见任务会做出一些假定。
###适配器可被实现为不兼容的方法调用之间的一个代码薄层。
例如将参数转换成接口的对应参数

##适配器模式的适用场合
适配器适用于客户系统期待的接口与现有API提供的接口不兼容的场合。只能用来协调语法上的差异问题。适配器所适配的两个方法执行的应该是类似的任务，否则就解决不了问题。
像桥接模式和门面模式一样，通过创建适配器，可以把抽象与其实现隔离开来，以便二者独立。


#装饰者模式
是一种不创建新子类而为对象增添特性的技术，，可用来透明地把对象包装在具有同样接口的另一对象之中。

#享元模式的实现步骤：
1、将所有外在数据从目标类剥离。
2、创建一个用来控制该类的实例化的工厂。这个工厂应该掌握该类所有已创建出来的独一无二的实例（用一个对象字面量来保存每一个这类对象的引用，并以用来生成这些对象的参数的唯一性组合作为他们的索引）（对象池：用数组来保存所创建的对象的引用。适合于注重可用对象的数量而不是那些单独配置的实例的场合）
3、创建一个用来保存外在数据的管理器。改管理器对象负责控制处理外在数据的种种事宜。
当要创建对象时，把所有数据都提供给管理器的某个方法，它会判断哪些是内在元素，哪些是外在元素，然后根据内在元素创建对象，吧外在元素存起来，随后根据需要将这些数据提供给共享对象的方法，效果就如同该类有许多实例一样。

##代理模式
代理模式最基本的形式是对访问进行控制，，代理对象和本体实现同样的接口，但实际工作是本体在做。，代理对象只是节制了对本体的访问。它实现的接口与本体完全相同，所以对它进行的方法调用都会被传递给本体